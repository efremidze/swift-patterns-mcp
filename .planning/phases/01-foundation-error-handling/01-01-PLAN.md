---
phase: 01-foundation-error-handling
plan: 01
type: execute
---

<objective>
Establish consistent error handling across the codebase.

Purpose: Replace inconsistent error handling (silent catches, mixed logging) with a unified pattern that logs context and degrades gracefully.
Output: Error utilities module and consistent error handling in cache.ts, rssPatternSource.ts, youtube.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase context:**
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md

**Files to modify:**
@src/utils/cache.ts
@src/sources/free/rssPatternSource.ts
@src/sources/premium/youtube.ts

**Current error handling issues:**
- cache.ts: Silent `catch {}` blocks with no logging
- rssPatternSource.ts: Inconsistent - some console.error, some silent catches
- youtube.ts: Mix of console.error and empty `catch {}`

**Established patterns (from CONVENTIONS.md):**
- Graceful degradation: Return empty arrays on non-critical failures
- Throw on critical failures (auth errors, missing required config)
- Return empty/null on recoverable failures (API timeouts, cache misses)
- Log context before throwing: `console.error('Context:', details)`

**Constraint:** No new dependencies - use console.error with structured context (logging library deferred).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error handling utilities</name>
  <files>src/utils/errors.ts</files>
  <action>
Create error utilities module with:

1. `logError(context: string, error: unknown, details?: Record<string, unknown>): void`
   - Logs error with context prefix, error message, and optional details
   - Extracts message from Error objects or stringifies unknown errors
   - Format: `console.error(`[${context}]`, message, details)`

2. `toErrorMessage(error: unknown): string`
   - Safely extracts error message from any thrown value
   - Returns error.message if Error, String(error) otherwise

3. Type guard `isError(value: unknown): value is Error`

Keep it simple - no classes, just utility functions. Follow existing conventions:
- Named exports
- camelCase function names
- JSDoc comments for public functions
  </action>
  <verify>File exists, `npm run lint` passes (tsc --noEmit)</verify>
  <done>src/utils/errors.ts created with logError, toErrorMessage, isError exports</done>
</task>

<task type="auto">
  <name>Task 2: Apply error handling to cache.ts</name>
  <files>src/utils/cache.ts</files>
  <action>
Import and use error utilities. Replace silent catches:

1. `get()` method (line ~67-69):
   - Change `catch {}` to `catch (error) { logError('FileCache.get', error, { key }); }`

2. `set()` method (line ~88-90):
   - Change `catch {}` to `catch (error) { logError('FileCache.set', error, { key }); }`

3. `clear()` method (line ~125-127):
   - Change `catch {}` to `catch (error) { logError('FileCache.clear', error); }`

4. `clearExpired()` method (lines ~154, ~161):
   - Inner catch: `catch (error) { logError('FileCache.clearExpired', error, { file }); ... }`
   - Outer catch: `catch (error) { logError('FileCache.clearExpired', error); }`

Maintain graceful degradation behavior (return null/continue on failures).
  </action>
  <verify>`npm run lint` passes, `npm run build` succeeds</verify>
  <done>All catch blocks in cache.ts log errors with context while maintaining graceful degradation</done>
</task>

<task type="auto">
  <name>Task 3: Apply error handling to sources</name>
  <files>src/sources/free/rssPatternSource.ts, src/sources/premium/youtube.ts</files>
  <action>
**rssPatternSource.ts:**
1. Import logError from utils/errors.js
2. `fetchPatterns()` (line ~52-55): Already has console.error - replace with:
   `logError('RssPatternSource.fetchPatterns', error, { feedUrl: this.options.feedUrl })`
3. `processArticle()` (line ~85-87): Silent catch - add:
   `logError('RssPatternSource.processArticle', error, { url })`

**youtube.ts:**
1. Import logError from utils/errors.js
2. `getChannelVideos()`:
   - Line ~34: Keep console.error for missing API key (user-facing config error)
   - Line ~44: Replace with `logError('YouTube.getChannelVideos', new Error(...), { channelId, status: searchRes.status })`
   - Line ~107-109: Replace with `logError('YouTube.getChannelVideos', err, { channelId })`
3. `searchVideos()`:
   - Line ~119: Add `logError('YouTube.searchVideos', new Error('YOUTUBE_API_KEY not set'))` before return
   - Line ~128: Add `logError('YouTube.searchVideos', new Error(...), { query, status: res.status })` before return
   - Line ~153-154: Replace empty catch with `logError('YouTube.searchVideos', error, { query })`

All changes maintain graceful degradation (return [] on failures).
  </action>
  <verify>`npm run lint` passes, `npm run build` succeeds</verify>
  <done>Both source files use consistent error handling with context logging</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run lint` passes (tsc --noEmit)
- [ ] `npm run build` succeeds
- [ ] All previously silent catches now log with context
- [ ] Graceful degradation preserved (functions still return empty arrays/null on failure)
- [ ] No new dependencies added
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Error handling is consistent across cache.ts, rssPatternSource.ts, youtube.ts
- Pattern established: logError(context, error, details) + graceful degradation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-error-handling/01-01-SUMMARY.md`
</output>
