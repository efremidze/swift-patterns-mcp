---
phase: 06-premium-source-testing
plan: 02
type: execute
---

<objective>
Add test coverage for Patreon OAuth token management.

Purpose: Ensure token storage, loading, refresh, and expiry detection work correctly.
Output: Test file `src/sources/premium/patreon-oauth.test.ts` with coverage of token management functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase context:**
@.planning/phases/06-premium-source-testing/06-01-SUMMARY.md

**Codebase context:**
@.planning/codebase/TESTING.md

**File to test:**
@src/sources/premium/patreon-oauth.ts

**Existing test patterns (reference):**
@src/sources/free/sundell.test.ts

**Functions to test:**
1. `saveTokens(tokens)` - Save tokens to keytar
2. `loadTokens()` - Load tokens from keytar
3. `clearTokens()` - Remove tokens from keytar
4. `isTokenExpired(tokens)` - Check if token is expired (5 min buffer)
5. `refreshAccessToken(clientId, clientSecret, refreshToken)` - Refresh via Patreon API

**Mocking requirements:**
- `keytar` module (native node module for secure storage)
- `fetch` for token refresh API calls
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test token storage and expiry functions</name>
  <files>src/sources/premium/patreon-oauth.test.ts</files>
  <action>
Create the test file with tests for keytar-backed token functions.

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  saveTokens,
  loadTokens,
  clearTokens,
  isTokenExpired,
  PatreonTokens
} from './patreon-oauth.js';

// Mock keytar
vi.mock('keytar', () => ({
  default: {
    setPassword: vi.fn(),
    getPassword: vi.fn(),
    deletePassword: vi.fn(),
  },
}));

import keytar from 'keytar';

describe('Patreon OAuth Token Management', () => {
  const mockTokens: PatreonTokens = {
    access_token: 'test-access-token',
    refresh_token: 'test-refresh-token',
    expires_at: Date.now() + 3600000, // 1 hour from now
    scope: 'identity identity.memberships',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('saveTokens', () => {
    it('saves tokens to keytar', async () => {
      await saveTokens(mockTokens);
      expect(keytar.setPassword).toHaveBeenCalledWith(
        'swift-mcp',
        'patreon-tokens',
        JSON.stringify(mockTokens)
      );
    });
  });

  describe('loadTokens', () => {
    it('loads tokens from keytar', async () => {
      vi.mocked(keytar.getPassword).mockResolvedValue(JSON.stringify(mockTokens));
      const tokens = await loadTokens();
      expect(tokens).toEqual(mockTokens);
    });

    it('returns null when no tokens stored', async () => {
      vi.mocked(keytar.getPassword).mockResolvedValue(null);
      const tokens = await loadTokens();
      expect(tokens).toBeNull();
    });

    it('returns null on parse error', async () => {
      vi.mocked(keytar.getPassword).mockResolvedValue('invalid json');
      const tokens = await loadTokens();
      expect(tokens).toBeNull();
    });
  });

  describe('clearTokens', () => {
    it('deletes tokens from keytar', async () => {
      await clearTokens();
      expect(keytar.deletePassword).toHaveBeenCalledWith('swift-mcp', 'patreon-tokens');
    });
  });

  describe('isTokenExpired', () => {
    it('returns false for valid token', () => {
      const tokens: PatreonTokens = {
        ...mockTokens,
        expires_at: Date.now() + 600000, // 10 min from now
      };
      expect(isTokenExpired(tokens)).toBe(false);
    });

    it('returns true for expired token', () => {
      const tokens: PatreonTokens = {
        ...mockTokens,
        expires_at: Date.now() - 1000, // 1 sec ago
      };
      expect(isTokenExpired(tokens)).toBe(true);
    });

    it('returns true when within 5 min buffer', () => {
      const tokens: PatreonTokens = {
        ...mockTokens,
        expires_at: Date.now() + 240000, // 4 min from now (within 5 min buffer)
      };
      expect(isTokenExpired(tokens)).toBe(true);
    });
  });
});
```
  </action>
  <verify>`npm test src/sources/premium/patreon-oauth.test.ts` passes</verify>
  <done>Token storage and expiry tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Test token refresh with mocked fetch</name>
  <files>src/sources/premium/patreon-oauth.test.ts</files>
  <action>
Add tests for `refreshAccessToken` function.

```typescript
describe('refreshAccessToken', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('refreshes token successfully', async () => {
    const newTokens = {
      access_token: 'new-access-token',
      refresh_token: 'new-refresh-token',
      expires_in: 2592000, // 30 days in seconds
      scope: 'identity identity.memberships',
      token_type: 'Bearer',
    };

    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: true,
      json: async () => newTokens,
    }));

    const { refreshAccessToken } = await import('./patreon-oauth.js');
    const result = await refreshAccessToken('client-id', 'client-secret', 'old-refresh-token');

    expect(result.access_token).toBe('new-access-token');
    expect(result.refresh_token).toBe('new-refresh-token');
    expect(result.expires_at).toBeGreaterThan(Date.now());
  });

  it('throws on API error', async () => {
    vi.stubGlobal('fetch', vi.fn().mockResolvedValue({
      ok: false,
      status: 401,
      text: async () => 'Unauthorized',
    }));

    const { refreshAccessToken } = await import('./patreon-oauth.js');
    await expect(refreshAccessToken('client-id', 'client-secret', 'bad-token'))
      .rejects.toThrow();
  });

  it('sends correct form data', async () => {
    const mockFetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => ({
        access_token: 'token',
        refresh_token: 'refresh',
        expires_in: 3600,
        scope: 'identity',
        token_type: 'Bearer',
      }),
    });
    vi.stubGlobal('fetch', mockFetch);

    const { refreshAccessToken } = await import('./patreon-oauth.js');
    await refreshAccessToken('my-client', 'my-secret', 'my-refresh');

    expect(mockFetch).toHaveBeenCalledWith(
      'https://www.patreon.com/api/oauth2/token',
      expect.objectContaining({
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      })
    );

    // Verify body contains correct params
    const callArgs = mockFetch.mock.calls[0][1];
    const body = callArgs.body.toString();
    expect(body).toContain('grant_type=refresh_token');
    expect(body).toContain('client_id=my-client');
    expect(body).toContain('client_secret=my-secret');
    expect(body).toContain('refresh_token=my-refresh');
  });
});
```

**Note:** You may need to adjust the import pattern due to module caching. If tests fail due to cached mocks, use `vi.resetModules()` before re-importing.
  </action>
  <verify>`npm test src/sources/premium/patreon-oauth.test.ts` passes with all tests</verify>
  <done>Token refresh tests pass with mocked fetch</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run lint` passes
- [ ] `npm test src/sources/premium/patreon-oauth.test.ts` passes
- [ ] Token storage functions tested (save, load, clear)
- [ ] Token expiry logic tested including 5-min buffer
- [ ] Token refresh API call tested with mocked fetch
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- patreon-oauth.test.ts covers token management functions
- Tests follow established patterns
</success_criteria>

<output>
After completion, create `.planning/phases/06-premium-source-testing/06-02-SUMMARY.md`
</output>
