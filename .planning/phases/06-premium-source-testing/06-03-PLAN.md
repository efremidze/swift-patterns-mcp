---
phase: 06-premium-source-testing
plan: 03
type: execute
---

<objective>
Add test coverage for PatreonSource class.

Purpose: Ensure PatreonSource can fetch patterns with proper mocking of OAuth, API, and file system.
Output: Test file `src/sources/premium/patreon.test.ts` with coverage of PatreonSource methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase context:**
@.planning/phases/06-premium-source-testing/06-01-SUMMARY.md
@.planning/phases/06-premium-source-testing/06-02-SUMMARY.md

**Codebase context:**
@.planning/codebase/TESTING.md

**File to test:**
@src/sources/premium/patreon.ts

**Existing test patterns (reference):**
@src/sources/free/sundell.test.ts

**PatreonSource dependencies to mock:**
1. `./patreon-oauth.js` - Token loading
2. `./youtube.js` - Video fetching
3. `./patreon-dl.js` - Downloaded content scanning
4. `../../config/creators.js` - Creator lookup
5. `fs` - File system for config
6. `fetch` - Patreon API calls

**Key methods to test:**
1. `constructor()` - Loads config from env and file
2. `getSubscriptions()` - Fetches user's Patreon memberships
3. `fetchPatterns(topic?, creatorIds?)` - Main pattern fetching method
4. Internal pattern conversion methods
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test PatreonSource constructor and configuration</name>
  <files>src/sources/premium/patreon.test.ts</files>
  <action>
Create test file with mocks for dependencies and tests for initialization.

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock all external dependencies before importing PatreonSource
vi.mock('./patreon-oauth.js', () => ({
  loadTokens: vi.fn().mockResolvedValue(null),
  getValidAccessToken: vi.fn().mockResolvedValue('mock-access-token'),
}));

vi.mock('./youtube.js', () => ({
  getChannelVideos: vi.fn().mockResolvedValue([]),
  searchVideos: vi.fn().mockResolvedValue([]),
}));

vi.mock('./patreon-dl.js', () => ({
  scanDownloadedContent: vi.fn().mockReturnValue([]),
}));

vi.mock('../../config/creators.js', () => ({
  getByPatreonId: vi.fn().mockReturnValue(null),
}));

vi.mock('fs', () => ({
  default: {
    existsSync: vi.fn().mockReturnValue(false),
    readFileSync: vi.fn().mockReturnValue('[]'),
  },
}));

vi.mock('../../utils/paths.js', () => ({
  getPatreonCreatorsPath: vi.fn().mockReturnValue('/mock/path/creators.json'),
}));

import { PatreonSource } from './patreon.js';

describe('PatreonSource', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    process.env = {
      ...originalEnv,
      PATREON_CLIENT_ID: 'test-client-id',
      PATREON_CLIENT_SECRET: 'test-client-secret',
    };
    vi.clearAllMocks();
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('constructor', () => {
    it('initializes with environment variables', () => {
      const source = new PatreonSource();
      // PatreonSource stores clientId and clientSecret from env
      expect(source).toBeDefined();
    });

    it('works without credentials (graceful degradation)', () => {
      delete process.env.PATREON_CLIENT_ID;
      delete process.env.PATREON_CLIENT_SECRET;
      const source = new PatreonSource();
      expect(source).toBeDefined();
    });
  });
});
```
  </action>
  <verify>`npm test src/sources/premium/patreon.test.ts` passes</verify>
  <done>PatreonSource constructor tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Test pattern fetching with mocked dependencies</name>
  <files>src/sources/premium/patreon.test.ts</files>
  <action>
Add tests for `fetchPatterns` method with various mock scenarios.

```typescript
import { scanDownloadedContent } from './patreon-dl.js';
import { getChannelVideos } from './youtube.js';
import { getByPatreonId } from '../../config/creators.js';

describe('fetchPatterns', () => {
  it('returns patterns from downloaded content', async () => {
    // Mock downloaded posts
    vi.mocked(scanDownloadedContent).mockReturnValue([
      {
        id: 'post-1',
        title: 'SwiftUI Tutorial',
        url: 'https://patreon.com/posts/1',
        publishDate: '2026-01-01',
        content: 'Learn SwiftUI with code examples: struct ContentView: View {}',
        creator: 'TestCreator',
        hasCode: true,
        codeFiles: [],
      },
    ]);

    const source = new PatreonSource();
    const patterns = await source.fetchPatterns();

    expect(patterns.length).toBeGreaterThan(0);
    expect(patterns[0].title).toBe('SwiftUI Tutorial');
    expect(patterns[0].topics).toContain('swiftui');
  });

  it('returns empty array when no content', async () => {
    vi.mocked(scanDownloadedContent).mockReturnValue([]);

    const source = new PatreonSource();
    const patterns = await source.fetchPatterns();

    expect(patterns).toEqual([]);
  });

  it('filters patterns by topic', async () => {
    vi.mocked(scanDownloadedContent).mockReturnValue([
      {
        id: 'post-1',
        title: 'SwiftUI Views',
        url: 'https://patreon.com/posts/1',
        publishDate: '2026-01-01',
        content: 'SwiftUI view content',
        creator: 'Creator',
        hasCode: false,
        codeFiles: [],
      },
      {
        id: 'post-2',
        title: 'Testing in Swift',
        url: 'https://patreon.com/posts/2',
        publishDate: '2026-01-01',
        content: 'XCTest framework',
        creator: 'Creator',
        hasCode: false,
        codeFiles: [],
      },
    ]);

    const source = new PatreonSource();
    const patterns = await source.fetchPatterns('swiftui');

    // Should return patterns that match the topic
    expect(patterns.every(p =>
      p.title.toLowerCase().includes('swiftui') ||
      p.topics.includes('swiftui')
    )).toBe(true);
  });

  it('calculates relevance scores', async () => {
    vi.mocked(scanDownloadedContent).mockReturnValue([
      {
        id: 'post-1',
        title: 'Swift Best Practices',
        url: 'https://patreon.com/posts/1',
        publishDate: '2026-01-01',
        content: 'Swift iOS development tutorial with code examples',
        creator: 'Creator',
        hasCode: true,
        codeFiles: [],
      },
    ]);

    const source = new PatreonSource();
    const patterns = await source.fetchPatterns();

    expect(patterns[0].relevanceScore).toBeGreaterThanOrEqual(0);
    expect(patterns[0].relevanceScore).toBeLessThanOrEqual(100);
  });
});
```

**Note:** The exact assertions may need adjustment based on how PatreonSource.fetchPatterns actually works. Adapt the mock return values and expectations to match the real implementation.
  </action>
  <verify>`npm test src/sources/premium/patreon.test.ts` passes with all tests</verify>
  <done>All PatreonSource tests pass with mocked dependencies</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run lint` passes
- [ ] `npm test src/sources/premium/patreon.test.ts` passes
- [ ] Constructor and initialization tested
- [ ] Pattern fetching tested with mocked downloaded content
- [ ] Topic filtering tested
- [ ] Relevance scoring tested
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- patreon.test.ts covers PatreonSource class
- Tests follow established patterns
- All premium source tests passing: youtube, patreon-oauth, patreon
</success_criteria>

<output>
After completion, create `.planning/phases/06-premium-source-testing/06-03-SUMMARY.md`
</output>
