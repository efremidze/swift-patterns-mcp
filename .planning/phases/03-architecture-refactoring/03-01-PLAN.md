---
phase: 03-architecture-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.ts
  - src/cli/router.ts
  - src/server.ts
  - src/tools/registration.ts
  - src/tools/validation.ts
  - src/tools/handlers/getSwiftPattern.ts
  - src/tools/handlers/searchSwiftContent.ts
  - src/tools/handlers/getPatreonPatterns.ts
  - src/tools/handlers/setupPatreon.ts
  - src/tools/handlers/enableSource.ts
autonomous: true

must_haves:
  truths:
    - "src/index.ts is under 60 lines and delegates to router, server, and registration modules"
    - "CLI routing (sources, patreon, setup subcommands) works identically to before via src/cli/router.ts"
    - "MCP server starts, registers tools, and serves requests identically to before"
    - "All 6 tool handlers use shared validation from src/tools/validation.ts"
    - "All 383 existing tests pass without modification"
  artifacts:
    - path: "src/cli/router.ts"
      provides: "CLI subcommand routing extracted from index.ts"
      exports: ["routeCli"]
    - path: "src/server.ts"
      provides: "MCP server init, source manager, transport, background tasks"
      exports: ["startServer"]
    - path: "src/tools/registration.ts"
      provides: "CORE_TOOLS and PATREON_TOOLS definitions, tool list assembly"
      exports: ["CORE_TOOLS", "PATREON_TOOLS", "getToolList"]
    - path: "src/tools/validation.ts"
      provides: "Shared argument validation utilities for all handlers"
      exports: ["validateRequiredString", "validateOptionalString", "validateOptionalNumber", "validateOptionalBoolean"]
    - path: "src/index.ts"
      provides: "Thin orchestrator delegating to router and server"
      max_lines: 60
  key_links:
    - from: "src/index.ts"
      to: "src/cli/router.ts"
      via: "import and call routeCli()"
      pattern: "routeCli"
    - from: "src/index.ts"
      to: "src/server.ts"
      via: "import and call startServer()"
      pattern: "startServer"
    - from: "src/server.ts"
      to: "src/tools/registration.ts"
      via: "import tool definitions for ListTools handler"
      pattern: "getToolList|CORE_TOOLS"
    - from: "src/tools/handlers/getSwiftPattern.ts"
      to: "src/tools/validation.ts"
      via: "import validateRequiredString for topic arg"
      pattern: "validateRequiredString"
    - from: "src/tools/handlers/enableSource.ts"
      to: "src/tools/validation.ts"
      via: "import validateRequiredString for source arg"
      pattern: "validateRequiredString"
---

<objective>
Decompose the monolithic entry point (src/index.ts, 254 lines) into focused modules and create a shared validation utility for all tool handlers.

Purpose: src/index.ts currently mixes 10 responsibilities (CLI routing, server init, tool registration, background tasks, etc.). Decomposing into single-responsibility modules makes each independently testable (Phase 4) and reduces cognitive load. Shared validation eliminates duplicated arg-checking boilerplate across 6 handlers.

Output: 4 new modules (cli/router.ts, server.ts, tools/registration.ts, tools/validation.ts), a thin index.ts orchestrator under 60 lines, and 5 updated handlers using shared validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/index.ts
@src/tools/index.ts
@src/tools/registry.ts
@src/tools/types.ts
@src/tools/handlers/getSwiftPattern.ts
@src/tools/handlers/searchSwiftContent.ts
@src/tools/handlers/getPatreonPatterns.ts
@src/tools/handlers/setupPatreon.ts
@src/tools/handlers/enableSource.ts
@src/tools/handlers/listContentSources.ts
@src/cli/setup.ts
@src/cli/patreon.ts
@src/cli/sources.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract CLI router, server module, and tool registration from index.ts</name>
  <files>
    src/cli/router.ts
    src/server.ts
    src/tools/registration.ts
    src/index.ts
  </files>
  <action>
Extract three modules from src/index.ts. The current file has these responsibilities to distribute:

**1. Create src/cli/router.ts** — Move CLI subcommand routing (lines 8-37 of current index.ts):
- Export an async function `routeCli(): Promise<boolean>` that returns true if a CLI command was handled (and the process should exit), false if MCP server should start.
- Move the CLI_COMMANDS record, SERVER_FLAGS set, subcommand detection, interactive wizard detection logic.
- The function checks process.argv, handles dynamic imports of CLI modules, and returns true if it routed to a CLI command or wizard.
- Do NOT call process.exit() inside router.ts — return the boolean and let index.ts handle exit.

**2. Create src/tools/registration.ts** — Move tool definitions (lines 81-183 of current index.ts):
- Export `CORE_TOOLS` and `PATREON_TOOLS` arrays (the Tool[] definitions with name, description, inputSchema).
- Export a function `getToolList(sourceManager: SourceManager, patreonSource: PatreonSourceConstructor | null): Tool[]` that assembles the full tool list based on enabled sources (the logic currently in the ListToolsRequestSchema handler).
- Import Tool type from "@modelcontextprotocol/sdk/types.js".
- Import SourceManager and PatreonSourceConstructor types.

**3. Create src/server.ts** — Move server initialization (lines 39-254 of current index.ts):
- Export an async function `startServer(): Promise<void>`.
- Move all MCP server logic: imports (Server, StdioServerTransport, etc.), patreon source loading, SourceManager init, auto-enable Patreon, tool context creation, server creation, ListToolsRequestSchema handler (using getToolList from registration.ts), CallToolRequestSchema handler, main() function with transport setup and background tasks.
- The startServer function contains everything from the MCP imports through the main().catch() at the end.

**4. Rewrite src/index.ts** as thin orchestrator (< 60 lines):
```typescript
#!/usr/bin/env node
import 'dotenv/config';
import { routeCli } from './cli/router.js';

const handled = await routeCli();
if (handled) {
  process.exit(0);
}

const { startServer } = await import('./server.js');
await startServer();
```
Note: Use dynamic import for server.ts so CLI commands don't load heavy MCP SDK dependencies. Keep the shebang line. This should be well under 60 lines.

CRITICAL CONSTRAINT: The behavior must be identical. The same CLI commands, same server startup, same tool registration, same background prefetch — just reorganized into modules. Do not change any logic, error handling, or control flow.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — zero type errors
2. Run `npx vitest run` — all 383 tests pass
3. Count lines: `wc -l src/index.ts` shows < 60 lines
4. Verify exports exist: `grep -c "export" src/cli/router.ts src/server.ts src/tools/registration.ts`
  </verify>
  <done>
src/index.ts is under 60 lines. CLI routing, server init, and tool registration are in dedicated modules. All 383 tests pass. TypeScript compiles with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared validation utility and update all 6 handlers</name>
  <files>
    src/tools/validation.ts
    src/tools/handlers/getSwiftPattern.ts
    src/tools/handlers/searchSwiftContent.ts
    src/tools/handlers/getPatreonPatterns.ts
    src/tools/handlers/setupPatreon.ts
    src/tools/handlers/enableSource.ts
  </files>
  <action>
**1. Create src/tools/validation.ts** with these exported functions:

```typescript
import { createTextResponse } from '../utils/response-helpers.js';
import type { ToolResponse } from './types.js';

/**
 * Validate a required string argument.
 * Returns the string value if valid, or a ToolResponse error if invalid/missing.
 */
export function validateRequiredString(
  args: Record<string, unknown>,
  name: string,
  usageHint?: string
): string | ToolResponse {
  const value = args?.[name];
  if (typeof value === 'string' && value.trim().length > 0) {
    return value.trim();
  }
  const msg = `Missing required argument: ${name}`;
  return createTextResponse(usageHint ? `${msg}\n\n${usageHint}` : msg);
}

/**
 * Validate an optional string argument.
 * Returns the string value, undefined if not provided, or a ToolResponse error if wrong type.
 */
export function validateOptionalString(
  args: Record<string, unknown>,
  name: string
): string | undefined | ToolResponse {
  const value = args?.[name];
  if (value === undefined || value === null) return undefined;
  if (typeof value === 'string') return value;
  return createTextResponse(`Invalid argument "${name}": expected string`);
}

/**
 * Validate an optional number argument.
 * Returns the number value, undefined if not provided, or a ToolResponse error if wrong type.
 */
export function validateOptionalNumber(
  args: Record<string, unknown>,
  name: string
): number | undefined | ToolResponse {
  const value = args?.[name];
  if (value === undefined || value === null) return undefined;
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  return createTextResponse(`Invalid argument "${name}": expected number`);
}

/**
 * Validate an optional boolean argument.
 * Returns the boolean value, undefined if not provided, or a ToolResponse error if wrong type.
 */
export function validateOptionalBoolean(
  args: Record<string, unknown>,
  name: string
): boolean | undefined | ToolResponse {
  const value = args?.[name];
  if (value === undefined || value === null) return undefined;
  if (typeof value === 'boolean') return value;
  return createTextResponse(`Invalid argument "${name}": expected boolean`);
}

/**
 * Type guard: check if a validation result is a ToolResponse (error).
 */
export function isValidationError(result: unknown): result is ToolResponse {
  return (
    typeof result === 'object' &&
    result !== null &&
    'content' in result &&
    Array.isArray((result as ToolResponse).content)
  );
}
```

**2. Update each handler** to use the validation functions. The pattern is:
```typescript
const topic = validateRequiredString(args, 'topic', 'Usage: ...');
if (isValidationError(topic)) return topic;
// topic is now typed as string
```

Specific handler updates:

**getSwiftPattern.ts**: Replace `const topic = args?.topic as string; if (!topic) { return createTextResponse(...) }` with `validateRequiredString(args, 'topic', 'Usage: get_swift_pattern(...) ...')`. Keep the existing usage hint text. Also validate `source` with `validateOptionalString` and `minQuality` with `validateOptionalNumber`.

**searchSwiftContent.ts**: Replace `const query = args?.query as string; if (!query) { return createTextResponse(...) }` with `validateRequiredString(args, 'query', 'Usage: search_swift_content(...)')`. Validate `requireCode` with `validateOptionalBoolean`.

**getPatreonPatterns.ts**: Replace `const topic = args?.topic as string | undefined` with `validateOptionalString(args, 'topic')`. Validate `requireCode` with `validateOptionalBoolean`, `minQuality` with `validateOptionalNumber`.

**setupPatreon.ts**: Replace `const action = (args?.action as string) || 'start'` with `validateOptionalString(args, 'action')` then default to 'start'.

**enableSource.ts**: Replace `const sourceId = args?.source as string` with `validateRequiredString(args, 'source', 'Usage: enable_source({ source: "patreon" })')`.

**listContentSources.ts**: No validation needed (no args). Leave unchanged.

IMPORTANT: Do NOT change the text content of error messages for required fields — keep the same usage hints. Only change the mechanism from inline type casting + manual checks to the shared validation functions. This ensures existing tests that check error messages still pass.

IMPORTANT: The validation functions return `ToolResponse` objects for errors. Check existing handler error message text and replicate it exactly in the usageHint parameter so tests continue to pass.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — zero type errors
2. Run `npx vitest run` — all 383 tests pass
3. Verify validation.ts is imported by handlers: `grep -l "validation" src/tools/handlers/*.ts` shows 5 files
4. Verify no more raw type casts in handlers: `grep "as string" src/tools/handlers/*.ts` should show zero or minimal results (some may remain for non-arg values)
  </verify>
  <done>
src/tools/validation.ts exists with validateRequiredString, validateOptionalString, validateOptionalNumber, validateOptionalBoolean, isValidationError exports. All 5 handlers with argument validation (getSwiftPattern, searchSwiftContent, getPatreonPatterns, setupPatreon, enableSource) use the shared validation. All 383 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `wc -l src/index.ts` — must be < 60 lines
2. `npx tsc --noEmit` — zero type errors (entire project)
3. `npx vitest run` — all 383 tests pass without modification
4. `ls src/cli/router.ts src/server.ts src/tools/registration.ts src/tools/validation.ts` — all 4 new files exist
5. Verify src/index.ts imports from router and server (not inline logic)
6. Verify all handlers import from validation.ts (except listContentSources which has no args)
</verification>

<success_criteria>
- src/index.ts is under 60 lines, delegating to cli/router.ts, server.ts, tools/registration.ts
- src/tools/validation.ts exists and is used by all 5 handlers that validate arguments
- All 383 existing tests pass without modification (backward compatibility)
- TypeScript compiles with zero errors
- No behavioral changes — CLI routing, server startup, tool responses are identical
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-refactoring/03-01-SUMMARY.md`
</output>
