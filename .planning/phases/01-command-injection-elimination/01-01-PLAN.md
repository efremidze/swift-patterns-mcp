---
phase: 01-command-injection-elimination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sources/premium/patreon-oauth.ts
  - src/sources/premium/patreon-dl.ts
autonomous: true

must_haves:
  truths:
    - "Shell metacharacters in cookie values cannot reach a shell interpreter"
    - "Shell metacharacters in URLs passed to browser-open cannot reach a shell interpreter"
    - "patreon-dl download commands execute without shell interpolation"
    - "Cookie values are validated for safe format before subprocess use"
    - "Existing download and OAuth functionality still works (no behavioral regression)"
  artifacts:
    - path: "src/sources/premium/patreon-oauth.ts"
      provides: "Safe browser-open via execFile"
      contains: "execFile"
    - path: "src/sources/premium/patreon-dl.ts"
      provides: "Safe patreon-dl invocation via execFile and cookie validation"
      contains: "execFile"
  key_links:
    - from: "src/sources/premium/patreon-dl.ts"
      to: "child_process.execFile"
      via: "import and usage for npx calls"
      pattern: "execFile.*npx"
    - from: "src/sources/premium/patreon-oauth.ts"
      to: "child_process.execFile"
      via: "import and usage for browser open"
      pattern: "execFile.*(open|start|xdg-open)"
    - from: "src/sources/premium/patreon-dl.ts"
      to: "cookie validation"
      via: "regex format check before execFile"
      pattern: "cookie.*match|test.*cookie"
---

<objective>
Eliminate command injection vectors in patreon-oauth.ts and patreon-dl.ts by replacing exec() with execFile() and adding cookie format validation.

Purpose: Close SEC-01 (shell command injection) and SEC-03 (cookie injection) so that user-controlled input (URLs, cookies) never reaches a shell interpreter.
Output: Two modified source files with safe subprocess invocation and input validation.
</objective>

<execution_context>
@/Users/home/.claude/get-shit-done/workflows/execute-plan.md
@/Users/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/sources/premium/patreon-oauth.ts
@src/sources/premium/patreon-dl.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace exec with execFile in both files</name>
  <files>src/sources/premium/patreon-oauth.ts, src/sources/premium/patreon-dl.ts</files>
  <action>
**patreon-oauth.ts (line 239):**

1. Change the import from `import { exec } from 'child_process'` to `import { execFile } from 'child_process'`.
2. Replace the browser-open call at line 239:
   ```
   // BEFORE (unsafe - shell interpolation):
   exec(`${cmd} "${authUrl.toString()}"`);

   // AFTER (safe - no shell):
   execFile(cmd, [authUrl.toString()], (err) => {
     if (err) {
       // Browser open is best-effort; URL is already printed to console
       console.error(`Failed to open browser: ${err.message}`);
     }
   });
   ```
   Note: On Windows, `start` is a shell built-in, not an executable. For Windows compatibility, use `execFile('cmd', ['/c', 'start', authUrl.toString()])` when `process.platform === 'win32'`. For darwin and linux, `open` and `xdg-open` are real executables so `execFile(cmd, [url])` works directly.

**patreon-dl.ts (lines 143, 187):**

1. Change the import from `import { exec } from 'child_process'` to `import { execFile } from 'child_process'`.
2. Replace `const execAsync = promisify(exec)` with `const execFileAsync = promisify(execFile)`.
3. Replace the command construction and execution in `downloadPost()` (line 143-144):
   ```
   // BEFORE (unsafe - shell interpolation):
   const cmd = `${PATREON_DL_COMMAND} --no-prompt -c "session_id=${cookie}" -o "${outDir}" "${postUrl}"`;
   await execAsync(cmd, { timeout: 120000 });

   // AFTER (safe - argument array, no shell):
   const args = ['--yes', PATREON_DL_PACKAGE, '--no-prompt', '-c', `session_id=${cookie}`, '-o', outDir, postUrl];
   await execFileAsync('npx', args, { timeout: 120000 });
   ```
4. Apply the same pattern to `downloadCreatorContent()` (line 187-188):
   ```
   // AFTER:
   const args = ['--yes', PATREON_DL_PACKAGE, '--no-prompt', '-c', `session_id=${cookie}`, '-o', outDir, creatorUrl];
   await execFileAsync('npx', args, { timeout: 300000 });
   ```
5. Remove the `PATREON_DL_COMMAND` string constant since we no longer build command strings. Keep `PATREON_DL_PACKAGE` as it is used in the args array.

**Why execFile, not exec:** `exec` passes the command string to a shell (`/bin/sh -c`), which interprets metacharacters like `;`, `$()`, backticks, and `&&`. `execFile` invokes the binary directly with an argv array, so no shell interpretation occurs. This is the Node.js recommended approach for preventing injection.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no type errors in modified files.
2. Run `npx vitest run` — existing tests still pass (no regressions).
3. Grep confirms no remaining `exec(` calls (only `execFile(`): `grep -rn "exec(" src/sources/premium/patreon-oauth.ts src/sources/premium/patreon-dl.ts` should show only execFile references.
  </verify>
  <done>
Both files use execFile instead of exec. No shell interpolation occurs for browser-open, post download, or creator download commands. TypeScript compiles and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cookie format validation before subprocess use</name>
  <files>src/sources/premium/patreon-dl.ts</files>
  <action>
Add a cookie validation function to patreon-dl.ts that checks the cookie value before it is passed to any subprocess argument.

1. Add a validation function near the top of the file (after the constants):
   ```typescript
   /**
    * Validate cookie value format to prevent injection.
    * Patreon session_id cookies are hex strings (typically 32-64 chars).
    * We allow alphanumeric characters, hyphens, and underscores.
    */
   function validateCookieValue(cookie: string): boolean {
     // Must be non-empty, reasonable length, and only safe characters
     return cookie.length > 0 && cookie.length <= 256 && /^[a-zA-Z0-9_-]+$/.test(cookie);
   }
   ```

2. In `downloadPost()`, after reading the cookie (line 136: `const cookie = fs.readFileSync(cookiePath, 'utf-8').trim()`), add validation:
   ```typescript
   if (!validateCookieValue(cookie)) {
     return { success: false, error: 'Invalid cookie format. Cookie must contain only alphanumeric characters, hyphens, and underscores.' };
   }
   ```

3. In `downloadCreatorContent()`, after reading the cookie (line 182), add the same validation:
   ```typescript
   if (!validateCookieValue(cookie)) {
     return { success: false, error: 'Invalid cookie format. Cookie must contain only alphanumeric characters, hyphens, and underscores.' };
   }
   ```

4. Also validate in `saveCookie()` to prevent invalid cookies from being stored in the first place:
   ```typescript
   export function saveCookie(cookie: string): void {
     const trimmed = cookie.trim();
     if (!validateCookieValue(trimmed)) {
       throw new Error('Invalid cookie format. Cookie must contain only alphanumeric characters, hyphens, and underscores.');
     }
     const cookiePath = getCookiePath();
     fs.mkdirSync(path.dirname(cookiePath), { recursive: true });
     fs.writeFileSync(cookiePath, trimmed);
   }
   ```

**Why validate:** Even though execFile prevents shell injection, defense-in-depth means we also validate the cookie format. A cookie containing unexpected characters indicates corruption or tampering. The regex `^[a-zA-Z0-9_-]+$` matches standard session ID formats while rejecting any characters that could be meaningful in shell, URL, or header contexts.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no type errors.
2. Run `npx vitest run` — existing tests still pass.
3. Grep confirms validateCookieValue is called before every use of cookie in subprocess args: `grep -n "cookie" src/sources/premium/patreon-dl.ts` should show validation calls before execFile calls.
  </verify>
  <done>
Cookie values are validated with a strict alphanumeric+hyphen+underscore regex before being passed to any subprocess. Invalid cookies cause an early return with a clear error message. saveCookie also validates on write.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. `npx vitest run` passes all existing tests
3. No `import { exec }` or bare `exec(` calls remain in either file (only `execFile`)
4. `validateCookieValue` is called before every cookie usage in subprocess arguments
5. `saveCookie` validates cookie format before writing to disk
</verification>

<success_criteria>
- SEC-01 CLOSED: Both patreon-oauth.ts and patreon-dl.ts use execFile with argument arrays. No shell interpolation occurs.
- SEC-03 CLOSED: Cookie values are validated against /^[a-zA-Z0-9_-]+$/ before any subprocess use. Invalid cookies are rejected with clear error messages.
- No behavioral regressions: TypeScript compiles, existing tests pass, download and OAuth flows structurally intact.
</success_criteria>

<output>
After completion, create `.planning/phases/01-command-injection-elimination/01-01-SUMMARY.md`
</output>
